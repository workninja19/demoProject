"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_native_1 = require("react-native");
var react_swipeable_views_core_1 = require("react-swipeable-views-core");
var windowWidth = react_native_1.Dimensions.get('window').width;
var styles = react_native_1.StyleSheet.create({
    root: {
        flex: 1,
        overflow: 'hidden',
    },
    container: {
        flex: 1,
        flexDirection: 'row',
    },
    slide: {
        flex: 1,
    },
});
var SwipeableViews = (function (_super) {
    __extends(SwipeableViews, _super);
    function SwipeableViews() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scrollViewNode = null;
        _this.handleScroll = function (event) {
            if (_this.state.displaySameSlide) {
                return;
            }
            if (_this.props.onSwitching) {
                _this.props.onSwitching(event.nativeEvent.contentOffset.x / _this.state.viewWidth, 'move');
            }
        };
        _this.handleMomentumScrollEnd = function (event) {
            var indexNew = event.nativeEvent.contentOffset.x / _this.state.viewWidth;
            var indexLatest = _this.state.indexLatest;
            _this.setState({
                indexLatest: indexNew,
            }, function () {
                if (_this.props.onSwitching) {
                    _this.props.onSwitching(indexNew, 'end');
                }
                if (_this.props.onChangeIndex && indexNew !== indexLatest) {
                    _this.props.onChangeIndex(indexNew, indexLatest);
                }
                if (_this.props.onTransitionEnd) {
                    _this.props.onTransitionEnd();
                }
            });
        };
        _this.handleLayout = function (event) {
            var width = event.nativeEvent.layout.width;
            if (width) {
                _this.setState({
                    viewWidth: width,
                    offset: {
                        x: _this.state.indexLatest * width,
                        y: 0,
                    },
                });
            }
        };
        return _this;
    }
    SwipeableViews.prototype.componentWillMount = function () {
        if (process.env.NODE_ENV !== 'production') {
            react_swipeable_views_core_1.checkIndexBounds(this.props);
        }
        var _a = this.props.index, index = _a === void 0 ? 0 : _a;
        this.setState({
            indexLatest: index,
            viewWidth: windowWidth,
            offset: {
                x: windowWidth * index,
                y: 0,
            },
        });
        if (this.props.animateHeight !== undefined) {
            console.warn('react-swipeable-view-native: The animateHeight property is not implement yet.');
        }
        if (this.props.axis !== undefined) {
            console.warn('react-swipeable-view-native: The axis property is not implement yet.');
        }
    };
    SwipeableViews.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var index = nextProps.index;
        if (typeof index === 'number' && index !== this.props.index) {
            if (process.env.NODE_ENV !== 'production') {
                react_swipeable_views_core_1.checkIndexBounds(nextProps);
            }
            var displaySameSlide_1 = react_swipeable_views_core_1.getDisplaySameSlide(this.props, nextProps);
            this.setState({
                displaySameSlide: displaySameSlide_1,
                indexLatest: index,
            }, function () {
                if (_this.scrollViewNode) {
                    _this.scrollViewNode.scrollTo({
                        x: _this.state.viewWidth * index,
                        y: 0,
                        animated: _this.props.animateTransitions && !displaySameSlide_1,
                    });
                }
            });
        }
    };
    SwipeableViews.prototype.render = function () {
        var _this = this;
        var _a = this.props, resistance = _a.resistance, children = _a.children, slideStyle = _a.slideStyle, style = _a.style, containerStyle = _a.containerStyle, disabled = _a.disabled, onTransitionEnd = _a.onTransitionEnd, other = __rest(_a, ["resistance", "children", "slideStyle", "style", "containerStyle", "disabled", "onTransitionEnd"]);
        var _b = this.state, viewWidth = _b.viewWidth, indexLatest = _b.indexLatest, offset = _b.offset;
        var slideStyleObj = [
            styles.slide,
            {
                width: viewWidth,
            },
            slideStyle,
        ];
        var childrenToRender = React.Children.map(children, function (child, index) {
            if (disabled && indexLatest !== index) {
                return null;
            }
            if (!React.isValidElement(child)) {
                console.warn("react-swipeable-view-native: one of the children provided is invalid: " + child + ". We are expecting a valid React Element.");
            }
            return React.createElement(react_native_1.View, { style: slideStyleObj }, child);
        });
        return (React.createElement(react_native_1.View, __assign({ onLayout: this.handleLayout, style: [styles.root, style] }, other),
            React.createElement(react_native_1.ScrollView, { ref: function (node) {
                    _this.scrollViewNode = node;
                }, horizontal: true, pagingEnabled: true, automaticallyAdjustContentInsets: false, scrollsToTop: false, bounces: resistance, onScroll: this.handleScroll, scrollEventThrottle: 16, showsHorizontalScrollIndicator: false, directionalLockEnabled: true, contentOffset: offset, onMomentumScrollEnd: this.handleMomentumScrollEnd, alwaysBounceVertical: false, keyboardDismissMode: "on-drag", style: [styles.container, containerStyle] }, childrenToRender)));
    };
    SwipeableViews.defaultProps = {
        animateTransitions: true,
        disabled: false,
        index: 0,
        resistance: false,
    };
    return SwipeableViews;
}(React.Component));
exports.default = SwipeableViews;
//# sourceMappingURL=SwipeableViews.scroll.js.map