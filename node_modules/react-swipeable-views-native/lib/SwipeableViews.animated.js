"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_native_1 = require("react-native");
var react_swipeable_views_core_1 = require("react-swipeable-views-core");
var styles = react_native_1.StyleSheet.create({
    root: {
        flex: 1,
        overflow: 'hidden',
    },
    container: {
        flex: 1,
        flexDirection: 'row',
    },
    slide: {
        flex: 1,
    },
});
function getAnimatedValue(animated) {
    return animated._value;
}
;
var SwipeableViews = (function (_super) {
    __extends(SwipeableViews, _super);
    function SwipeableViews() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.panResponder = undefined;
        _this.startX = 0;
        _this.startIndex = 0;
        _this.handleAnimationFinished = function (params) {
            if (_this.props.onTransitionEnd && params.finished) {
                _this.props.onTransitionEnd();
            }
        };
        _this.handleTouchStart = function (event, gestureState) {
            if (_this.props.onTouchStart) {
                _this.props.onTouchStart(event, gestureState);
            }
            _this.startX = gestureState.x0;
            _this.startIndex = getAnimatedValue(_this.state.indexCurrent);
        };
        _this.handleTouchMove = function (event, gestureState) {
            var _a = _this.props, children = _a.children, onSwitching = _a.onSwitching, resistance = _a.resistance;
            var _b = react_swipeable_views_core_1.computeIndex({
                children: children,
                resistance: resistance,
                pageX: gestureState.moveX,
                startIndex: _this.startIndex,
                startX: _this.startX,
                viewLength: _this.state.viewLength,
            }), index = _b.index, startX = _b.startX;
            if (startX) {
                _this.startX = startX;
            }
            _this.state.indexCurrent.setValue(index);
            if (onSwitching) {
                onSwitching(index, 'move');
            }
        };
        _this.handleTouchEnd = function (event, gestureState) {
            var _a = _this.props, _b = _a.threshold, threshold = _b === void 0 ? 0 : _b, _c = _a.hysteresis, hysteresis = _c === void 0 ? 0 : _c, onChangeIndex = _a.onChangeIndex, onTouchEnd = _a.onTouchEnd, onSwitching = _a.onSwitching, children = _a.children;
            if (onTouchEnd) {
                onTouchEnd(event, gestureState);
            }
            var vx = gestureState.vx, moveX = gestureState.moveX;
            var indexLatest = _this.state.indexLatest;
            var indexCurrent = indexLatest + (_this.startX - moveX) / _this.state.viewLength;
            var delta = indexLatest - indexCurrent;
            var indexNew;
            if (Math.abs(vx) * 10 > threshold) {
                if (vx > 0) {
                    indexNew = Math.floor(indexCurrent);
                }
                else {
                    indexNew = Math.ceil(indexCurrent);
                }
            }
            else if (Math.abs(delta) > hysteresis) {
                indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);
            }
            else {
                indexNew = indexLatest;
            }
            var indexMax = React.Children.count(children) - 1;
            if (indexNew < 0) {
                indexNew = 0;
            }
            else if (indexNew > indexMax) {
                indexNew = indexMax;
            }
            _this.setState({
                indexLatest: indexNew,
            }, function () {
                _this.animateIndexCurrent(indexNew);
                if (onSwitching) {
                    onSwitching(indexNew, 'end');
                }
                if (onChangeIndex && indexNew !== indexLatest) {
                    onChangeIndex(indexNew, indexLatest);
                }
            });
        };
        _this.handleLayout = function (event) {
            var width = event.nativeEvent.layout.width;
            if (width) {
                _this.setState({
                    viewLength: width,
                });
            }
        };
        return _this;
    }
    SwipeableViews.prototype.componentWillMount = function () {
        if (process.env.NODE_ENV !== 'production') {
            react_swipeable_views_core_1.checkIndexBounds(this.props);
        }
        var _a = this.props.index, index = _a === void 0 ? 0 : _a;
        this.setState({
            indexLatest: index,
            indexCurrent: new react_native_1.Animated.Value(index),
            viewLength: react_native_1.Dimensions.get('window').width,
        });
        this.panResponder = react_native_1.PanResponder.create({
            onStartShouldSetPanResponder: function () { return true; },
            onMoveShouldSetPanResponder: function (event, gestureState) {
                var dx = Math.abs(gestureState.dx);
                var dy = Math.abs(gestureState.dy);
                return dx > dy && dx > react_swipeable_views_core_1.constant.UNCERTAINTY_THRESHOLD;
            },
            onPanResponderRelease: this.handleTouchEnd,
            onPanResponderTerminate: this.handleTouchEnd,
            onPanResponderMove: this.handleTouchMove,
            onPanResponderGrant: this.handleTouchStart,
        });
        if (this.props.animateHeight !== undefined) {
            console.warn('react-swipeable-view-native: The animateHeight property is not implement yet.');
        }
        if (this.props.axis !== undefined) {
            console.warn('react-swipeable-view-native: The axis property is not implement yet.');
        }
    };
    SwipeableViews.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var index = nextProps.index, animateTransitions = nextProps.animateTransitions;
        if (typeof index === 'number' && index !== this.props.index) {
            if (process.env.NODE_ENV !== 'production') {
                react_swipeable_views_core_1.checkIndexBounds(nextProps);
            }
            var displaySameSlide = react_swipeable_views_core_1.getDisplaySameSlide(this.props, nextProps);
            if (animateTransitions && !displaySameSlide) {
                this.setState({
                    indexLatest: index,
                }, function () {
                    _this.animateIndexCurrent(index);
                });
            }
            else {
                this.setState({
                    indexLatest: index,
                    indexCurrent: new react_native_1.Animated.Value(index),
                });
            }
        }
    };
    SwipeableViews.prototype.animateIndexCurrent = function (index) {
        if (getAnimatedValue(this.state.indexCurrent) !== index) {
            react_native_1.Animated.spring(this.state.indexCurrent, __assign({ toValue: index }, this.props.springConfig)).start(this.handleAnimationFinished);
        }
        else {
            this.handleAnimationFinished({
                finished: true,
            });
        }
    };
    SwipeableViews.prototype.render = function () {
        var _a = this.props, children = _a.children, style = _a.style, slideStyle = _a.slideStyle, containerStyle = _a.containerStyle, disabled = _a.disabled, hysteresis = _a.hysteresis, index = _a.index, onTransitionEnd = _a.onTransitionEnd, onTouchEnd = _a.onTouchEnd, onTouchStart = _a.onTouchStart, other = __rest(_a, ["children", "style", "slideStyle", "containerStyle", "disabled", "hysteresis", "index", "onTransitionEnd", "onTouchEnd", "onTouchStart"]);
        var _b = this.state, indexCurrent = _b.indexCurrent, viewLength = _b.viewLength;
        var slideStyleObj = [styles.slide, slideStyle];
        var childrenToRender = React.Children.map(children, function (child) {
            if (!React.isValidElement(child)) {
                console.warn("react-swipeable-view-native: one of the children provided is invalid: " + child + ". We are expecting a valid React Element.");
            }
            return React.createElement(react_native_1.View, { style: slideStyleObj }, child);
        });
        var sceneContainerStyle = [
            styles.container,
            {
                width: viewLength * React.Children.count(children),
                transform: [
                    {
                        translateX: indexCurrent.interpolate({
                            inputRange: [0, 1],
                            outputRange: [0, -viewLength],
                        }),
                    },
                ],
            },
            containerStyle,
        ];
        var panHandlers = disabled ? {} : this.panResponder.panHandlers;
        return (React.createElement(react_native_1.View, __assign({ style: [styles.root, style], onLayout: this.handleLayout }, other),
            React.createElement(react_native_1.Animated.View, __assign({}, panHandlers, { style: sceneContainerStyle }), childrenToRender)));
    };
    SwipeableViews.defaultProps = {
        animateTransitions: true,
        disabled: false,
        hysteresis: 0.6,
        index: 0,
        resistance: false,
        springConfig: {
            tension: 300,
            friction: 30,
        },
        threshold: 5,
    };
    return SwipeableViews;
}(React.Component));
exports.default = SwipeableViews;
//# sourceMappingURL=SwipeableViews.animated.js.map